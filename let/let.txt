一.let命令
(1).基本用法
1.let命令类似于var用来声明变量。但是let命令只能在所在的代码块内有效。
eg：{
	let a = 10；
	var b = 1；
}

a //a is not difined;
b // 1;

2. for循环的计数器很适合用let命令。

(2).不存在变量提升。
1.通过var声明的变量会发生变量提升。在声明变量之前打印变量会输出undefined。但是使用let命令声明在此之前会不存在的，会报错。

(3).暂时性死区

1.在代码块中使用let命令声明变量之前，该变量都是不可用的，这称为“暂时性死区”。
2.如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

(4).不允许重复声明
1.let不允许在相同作用域内，重复声明同一个变量。

二.块级作用域
(1)为什么使用块级作用域？
1.ES5只有全局作用域和函数作用域，没有块级作用域。这会带来很多不合理的场景。
a.内层变量可能会覆盖外层变量。
eg:var temp = new Date();

	function f() {
		console.log(temp);
		if(false) {
			var temp = "hello world";
		}
	}

	f();

f()函数执行后输出的是undefined，原因在于变量的提升，导致内层的temp覆盖了外层的。

b.用来计数的循环变量泄露为全局变量。
eg：
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5

上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

2.ES6的块级作用域
a.let实际上javascript新增了块级作用域。
eg:function f1() {
	  let n = 5;
	  if (true) {
	    let n = 10;
	  }
	  console.log(n); // 5
	}

运行结果表示外层代码块不受内层的影响。如果使用var来定义的话，输出结果是10。

3.块级作用域与函数声明
a.ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
b.ES6规定：允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

三.const命令
1.基本用法
a.const声明一个只读常量，一旦声明常量的值不能改变。const一旦声明变量就必须立即初始化，不能留到以后赋值，不然会报错。
b.const的作用域与let命令相同：只在声明所在的块级作用域内有效。const的作用域与let命令相同：只在声明所在的块级作用域内有效。const声明的常量，也与let一样不可重复声明。 

2.本质
a.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
b.如果真的想将对象冻结，应该使用Object.freeze方法。添加新属性不起作用.